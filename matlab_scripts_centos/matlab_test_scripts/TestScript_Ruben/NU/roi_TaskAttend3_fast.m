%%%90 TRs%%%% roiRD_FT: Flickering Random-Dot Localizer program % Protocol:  First fix 12s, alternating randomChecks presented in LVF and RVF (12-s, 10blocks/cond) , Last fix 12s% Duration = 300 s (5 min 0 sec) or 150 acq (TR=2)%% Stimulus Conditions: Flickering random checks presented in left or right% visual field% Task: press button 1 whenever flickering`` checks briefly disappear.%% Stimulus parameters:%      	contrast 100%: white and black checks%		Flicker rate: 10 Hz%%	Stimulus window: regular or Gaussian-blurred window %	Stimulus size = 2-8 deg for regular window%		(inset by 1 deg compared to orientation stimulus in reg window of 1-9 deg radius)%		By selecting a smaller retinotopic ROI, can minimize edge effects%% % Created by Frank Tong on July 25, 2006, modified for OSx on July 13, 2007, by Janneke Jeheeecho offclear all				% clear all variablesclose all hidden;		% close all windows including hidden onessituation = 2; %0=elsewhere, 1=old scanner, 2=new scanner%%%%%%%%%%%%%%%%     Basic Program Settings & Variables    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global expdir mpimagelist mpcmaplist wptr dacsize globaldir	%Cognitive toolbox global variables       % Identify Computer: Directory & Monitor Settings	expdir= pwd;		% set experimental directory to current dir of programind_globaldir = find(expdir==filesep,1,'last');globaldir = expdir(1:ind_globaldir);datadir='ScanData/'; if ~exist(datadir, 'dir'), mkdir(datadir); endaddpath([globaldir 'Local_Functions']);%%%%%  Get Info from User  %%%%%  [subName scanNum theDate] = GetUserInfo;					% function gets subject's initials, scan number & date[scrnum,frameHz,pixPerDeg,bigRect,calibrationFile] = GetMonitorInfo(situation); %0=elsewhere, 1=old scanner, 2=new scanner% Query Scan Type: set Gaussian/nonGaussian window, contrast, spatial frequency% p.stimType = input('What type of stimulus window?  (1=Gaussian, 2=Regular)  ');% if p.stimType ~=1 && p.stimType ~=2 % 	error('Invalid stimulus window entered');% elseif p.stimType == 2%     error('Type 2 is not updated to OsX');% end% disp(['Stimulus window type: ' num2str(p.stimType)]); p.stimType =1;datafile = [theDate subName '_roiTaskAttend_r' scanNum '_g' num2str(p.stimType) ];	% name of data file to save relevant variables %%DATAFILE%%%%%%%%%%%%%%%%     Main Experimental Parameters     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Experimental Conditions and Block Timesp.block_dur = 12;	% duration of each stimulus period (seconds)p.contrast = [1.0, 1.0, 1.0];	% contrast of each component %sequence of stimulus blocks% p.stim_seq = [0,  1 0 1 0, 1 0 1 0, 1 0 1 0, 1 0 1 0, 1 0 1 0, 0;...	% LVF, 0 = fixation rest, 1=45-deg grating, 2=135 tilted grating%  			  0,  0 1 0 1, 0 1 0 1, 0 1 0 1, 0 1 0 1, 0 1 0 1, 0];		% RVFp.stim_seq = [	0 1 0 0 0 1 0 0 0 1 0 0 0 1 0;...	% CENTRAL~HACK, (original: LVF) 0 = fixation rest, 1=flickering checks				0 0 0 1 0 0 0 1 0 0 0 1 0 0 0];		% CENTRAL (original: RVF)% p.stim_seq = [1 0 1 0;...	% LVF, 0 = fixation rest, 1=flickering checks%  			  0 1 0 1];		% RVFidx = 1:length(p.stim_seq); 	% index locations in p.stim_seqidx(p.stim_seq(1,:)>0) = shuffle(idx(p.stim_seq(1,:)>0));	% find all non-zero conditions, idx locations, and shuffle themp.stim_seq = p.stim_seq(:,idx);	% randomized order of stimulus conditions				p.nblocks = length(p.stim_seq);			% number of blocks per exptp.nconds = max(p.stim_seq);p.trialsPerBlock = 1;resp.rt = zeros(p.trialsPerBlock, p.nblocks);resp.key = zeros(p.trialsPerBlock, p.nblocks);disp(['Order of conditions: ' num2str(p.stim_seq(1,:))]);	% display order of conditions, back-up if program crashs partway through exptdisp(['Order of conditions: ' num2str(p.stim_seq(2,:))]);	% display order of conditions, back-up if program crashs partway through expttotalDur = p.nblocks*p.block_durp.ppd = pixPerDeg;	 % pix_per_deg = 40.76 	% pixPerDeg for Vandy avotec scanner at 1024 x 768 resolutionp.meanRGB =  [0.5, 0.5, 0.5];	% mean luminance of each component grating [R,G,B], ** G OR B MUST EQUAL ZERO *,p.frame_rate = 	frameHz;	p.randseed = rand('state'); % stores the current state of the rand number generator% Stimulus Parameters for hemifield Gabor gratingss.size_in_degree = 15;s.width_in_pixels = round(s.size_in_degree*pixPerDeg); %width of rect stims.size_in_pixels = [s.width_in_pixels s.width_in_pixels];	% width, height of stimuluss.radius = round(s.width_in_pixels/2);	% s.radius_inset = round(pixPerDeg);	% inset the regular window checks by this amount, e.g. R=2-8 deg rather than 1-9deg s.loc = [(round((bigRect(3) -s.size_in_pixels(1))/2)), round((bigRect(4)-s.size_in_pixels(2))/2)];s.checksize_cpd = 1; s.checksize = round(pixPerDeg/(2*s.checksize_cpd));s.gauss_center_in_degree = 1.5;	s.gauss_center = s.gauss_center_in_degree*pixPerDeg;s.gauss_sd = round(s.width_in_pixels/4);s.start_linear_decay_in_degree = .5; s.start_linear_decay = round(s.start_linear_decay_in_degree*pixPerDeg);s.gauss_thresh = round(s.width_in_pixels/2);% s.gauss_angle = 45;		% standard deviation to use for Gaussian mask of polar angle grating% s.gauss_angle_thresh = 75;	% threshold polar angle for Gaussian mask, spare middle 30deg of central meridians.numImages = 10;	% number of random check images to makes.bcolor = p.meanRGB(1);s.contrast = [p.contrast];		% contrast of each component			s.fixRadius_in_degree = .25;s.fixRadius_in_pixels = round([1/3 2/3 1]*s.fixRadius_in_degree*pixPerDeg);s.fixSize = [max(s.fixRadius_in_pixels) max(s.fixRadius_in_pixels)]*2;	%image size, width, heights.fixLoc = round([(bigRect(3:4)-s.fixSize)]/2);	% fixation point at center of screen;s.onDur = 0.10;		% duration that stimulus is on for each presentations.offDur = 0;		% duration between each stimulus presentations.onOffDur = s.onDur + s.offDur;%%%% MAKE GAMMA-CORRECTED COLOR LOOK-UP TABLE: MPCMAPLIST %%%%% calibrationFile = 'calib_12-May-2006.mat';% [gamInverse,dacsize] = LoadCalibrationFileFeb2008(calibrationFile);		% function loads inverse gamma table and screen dacsize from most recent calibration file%  % ncolors = 255;	% number of gray levels to use in mpcmaplist% mpcmaplist = zeros(256,3);	% color look-up table of 256 RGB values, RANGE 0-1% % if or(or(p.meanRGB(1)~=p.meanRGB(2),p.meanRGB(1)~=p.meanRGB(3)), p.meanRGB(2)~=p.meanRGB(3))%     error('the three entries in meanRGB are not the same...')% end% % temptrial = linspace(p.meanRGB(1)-p.meanRGB(1)*s.contrast(1), p.meanRGB(1)+p.meanRGB(1)*s.contrast(1), ncolors)';	% make grayscale gradient% % gray_idx = find(temptrial==.5) -1;	% black_idx = find(temptrial==0) -1;% white_idx = find(temptrial==1) -1;% bcolor_idx = gray_idx; % idx of background color in mpcmaplist, subtract 1 for range 0-255 % mid_cmap_idx = ceil((ncolors)/2) -1;	% midpoint of linearly increasing cmap% cmap_amp = floor((ncolors-1)/2);		% +/- range of cmap, relative to midpoint% 		% code works for both odd and even number of ncolors, though odd number is preferred for using exact midpoint%         % if (mid_cmap_idx ~= bcolor_idx)%     error('background ColorIdx and mean ColorIdx are not the same')% end% % mpcmaplist(1:ncolors,:) = repmat(temptrial, [1 3]);% mpcmaplist(256,1:3) = 1;% mpcmaplist = round(map2map(mpcmaplist,gamInverse));gray_idx = 127;black_idx = 0;white_idx = 255;bcolor_idx = gray_idx;ncolors = 255;mid_cmap_idx = ceil((ncolors)/2)-1;%%%%%%%%%%%%%%%%     Initilize Monitors%%%%%%%%%%%%%%%%     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%try[wptr,rect] = Screen('OpenWindow', 0, bcolor_idx, [], 8);hardwareclut=Screen('LoadCLUT', wptr);%Screen('LoadCLUT', wptr, mpcmaplist); %OSx USE LoadNormalizedGammaTable, but: Gamma Table Values must be in interval 0 =< x =< 1rect = [s.loc, s.loc + s.size_in_pixels]; middle_rect = [round(bigRect(3:4)/2) - [s.fixRadius_in_pixels(3), s.fixRadius_in_pixels(3)], round(bigRect(3:4)/2) + [s.fixRadius_in_pixels(3), s.fixRadius_in_pixels(3)]];	% rect (location) for fixation in middle of screen% Create maskif p.stimType == 1    mask1 = makeLinearMaskCircleAnn(s.width_in_pixels,s.width_in_pixels, s.gauss_center, s.start_linear_decay, s.gauss_thresh); %create mask%     mask1 = makeGaussMaskCircle(s.width_in_pixels,s.width_in_pixels, s.gauss_center, s.gauss_sd, s.gauss_thresh); %create maskelseif p.stimType == 2%     s.gauss_thresh = s.gauss_thresh - s.radius_inset;	% INSET RADIUS BY FIXED AMOUNT%     mask_ring  = makeMaskCircle(s.width_in_pixels,s.width_in_pixels, s.gauss_center, s.gauss_sd, s.gauss_thresh);%     mask_lvf = makeMaskAngle(s.width_in_pixels,s.width_in_pixels, 180, s.gauss_angle, s.gauss_angle_thresh);%     mask_rvf = makeMaskAngle(s.width_in_pixels,s.width_in_pixels, 0, s.gauss_angle, s.gauss_angle_thresh);end% Create imagesmpimagelist = [];	% index of pointer to imagesfor n = 1:s.numImages         img = MakeRandomChecks(s.width_in_pixels,s.width_in_pixels,s.checksize, -1, 1);			    img = img.*mask1;		% make Gaussian masked grating    img = round(img*(ncolors-1)/2 + (ncolors-1)/2);	% adjust range to meanlum-amp to meanlum+amp    mpimagelist(n,1) = Screen('MakeTexture', wptr, img);end% make blank fixation imagestim = MakeFixation(black_idx, white_idx, mid_cmap_idx, s.fixRadius_in_pixels(1), s.fixRadius_in_pixels(2), s.fixRadius_in_pixels(3)); 	blank_img_idx = length(mpimagelist)+1;% index of blank image with fixation pointmpimagelist(blank_img_idx,1) = Screen('MakeTexture', wptr, stim);%%%%%%%%%%%%%%%%     START EXPERIMENT    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%HideCursor;  %%DEBUGFlushEvents('keyDown');							% discard all characters from the Event Manager queuep.block_switch_times = [0 p.block_dur * (1:p.nblocks)];	% when to switch between block types (starting at time 0)stimPerMovie = floor(p.block_dur/(s.onDur+s.offDur));p.trial_switch_times = [0 (1:stimPerMovie)*(s.onDur+s.offDur)]; % when to switch between block types (starting at time 0)p.lvf_list = zeros(stimPerMovie, p.nblocks);	% list of LVF images to be shown in each stimulus blockp.rvf_list = zeros(stimPerMovie, p.nblocks);	% list of RVF images to be shown in each stimulus blockp.task_list = zeros(stimPerMovie, p.nblocks);	% p.probe_Trange = [2, 8]; % time interval between probesstimRate = 1/s.onOffDur;for i = 1:length(p.stim_seq)	if sum(p.stim_seq(:,i))		a = rand(stimPerMovie,1)*(p.probe_Trange(2)-p.probe_Trange(1)) + p.probe_Trange(1);	% random intervals between probes		a = round(cumsum(a) / s.onOffDur); % when to present probe`, by image number in movie		a = a(a<stimPerMovie);			p.task_list(a,i) = 1;	% present probe for these images in the movielist	end		if p.stim_seq(1,i)	% if a stimulus block for LVF %%HACK, both are central		p.lvf_list(:,i) = randSamp([1:s.numImages], stimPerMovie, 'n');	% select random sequence of images	end							if p.stim_seq(2,i)	% if a stimulus block, for RVF %%HACK, both are central		p.rvf_list(:,i) = randSamp([1:s.numImages], stimPerMovie, 'n');	% select random sequence of images	end						endresp.rt = zeros(stimPerMovie, p.nblocks);	%  response time on each blockresp.key = zeros(stimPerMovie, p.nblocks);	%  response key (1 or 2) on each block% Start Experiment: prepare presentation screen, color table, and clear% screenScreen(wptr,'TextSize',14);Screen(wptr,'TextStyle',[1]);txt = 'Waiting for trigger to begin';		% draw text message, reader for exp't	txtloc = [50 50];Screen('DrawTexture', wptr, mpimagelist(blank_img_idx), [], middle_rect);Screen('DrawText',wptr,txt,txtloc(1), txtloc(2),white_idx); %add text to fixation pointScreen('Flip', wptr);% draw text message, reader for exp'thalf_flip_interval = 0.5*Screen('GetFlipInterval',wptr); % Create value in seconds that is half the frame period.waitTrigger;	% exp't starts after MR trigger sends ` keyScreen('DrawTexture', wptr, mpimagelist(blank_img_idx), [], middle_rect);flip_time_stamp = Screen('Flip', wptr);% draw fixation pointT.start_time = flip_time_stamp;for i = 1:length(p.stim_seq) %% i = block					    if sum(p.stim_seq(:,i))	% if a stimulus block                keyboard_response_detected = 0;        for n = 1:stimPerMovie            if n == 1                                if p.task_list(n,i)                    Screen('DrawTexture', wptr, mpimagelist(blank_img_idx)); % draw fixation point                                        flip_time_stamp = Screen('Flip', wptr);                elseif p.task_list(n,i) == 0                                        if p.lvf_list(n,i)                    Screen('DrawTextures', wptr, [mpimagelist(p.lvf_list(n,i),1) mpimagelist(blank_img_idx)], [], [rect; middle_rect]');	% draw central image                    flip_time_stamp = Screen('Flip', wptr);                    end                    if p.rvf_list(n,i)                    Screen('DrawTextures', wptr, [mpimagelist(p.rvf_list(n,i),1) mpimagelist(blank_img_idx)], [], [rect; middle_rect]');	% draw central image                    flip_time_stamp = Screen('Flip', wptr);                    end                end		                                T.start_block(i) = flip_time_stamp - T.start_time;                            elseif n > 1                flip_time_stamp = Screen('Flip', wptr);%                 T.stim_dur(i,n-1) = flip_time_stamp- T.stim_dur(i,n-1); %%DEBUG            end            T.start_trial(i,n) = flip_time_stamp - T.start_time - T.start_block(i);            % prepare the next video page            if n < stimPerMovie                 if p.task_list(n,i)                                        Screen('DrawTexture', wptr, mpimagelist(blank_img_idx)); % draw fixation point                                    elseif p.task_list(n,i) == 0                    if p.lvf_list(n+1,i)                        Screen('DrawTextures', wptr, [mpimagelist(p.lvf_list(n+1,i),1) mpimagelist(blank_img_idx)], [], [rect; middle_rect]');	% draw central image                    end                    if p.rvf_list(n+1,i)                        Screen('DrawTextures', wptr, [mpimagelist(p.rvf_list(n+1,i),1) mpimagelist(blank_img_idx)], [], [rect; middle_rect]');	% draw central image                    end		                end                            elseif n == stimPerMovie                 Screen('DrawTexture', wptr, mpimagelist(blank_img_idx)); % draw fixation point            end %end prep next screen%             T.stim_dur(i,n) = flip_time_stamp; %%DEBUG            FlushEvents('keyDown');            while GetSecs -p.block_switch_times(i)-T.start_time < s.onOffDur*(n-1) + s.onDur - half_flip_interval	% wait for end of time for given stimulus            %                 [keyIsDown, secs, keyCode] = KbCheck; %                 if (keyIsDown && keyboard_response_detected == 0)%                     key = KbName(keyCode);%                     if (key(1) == '1')%                         resp.rt(n,i) =  secs-T.start_time;	% record time of keypress%                         resp.key(n,i) = str2num(key(1));%                         keyboard_response_detected = 1;%                     end%                 elseif (~keyIsDown && keyboard_response_detected == 1)%                     keyboard_response_detected = 0;%                 end                if(CharAvail)	% check for keypress, record if key=1                    [char, when] = getChar;                    if (char =='1')                        resp.key(n,i) =  str2num(char);	                        resp.rt(n,i) = when.secs-T.start_time; % record time of keypress                        keyboard_response_detected = 1;                    end                    FlushEvents('keyDown');		% discard all characters from the Event Manager queue					                end	            end %while        end %n = 1:stimPerMovie        flip_time_stamp = Screen('Flip', wptr); % n==stimPerMovie, draw fixation    else	% otherwise, a fixation rest period        Screen('DrawTexture', wptr, mpimagelist(blank_img_idx)); % draw fixation point        flip_time_stamp = Screen('Flip', wptr);	        T.start_block(i) = flip_time_stamp - T.start_time;        while (GetSecs - T.start_time < p.block_switch_times(i+1)- half_flip_interval)            WaitSecs(0.001)        end        FlushEvents('keyDown');		% discard all characters from the Event Manager queue					    end		endflip_time_stamp = Screen('Flip', wptr);T.end_time = flip_time_stamp;% close presentation screenScreen('LoadCLUT', wptr, hardwareclut); Screen('CloseAll');ShowCursor;disp('Experiment done');T.expt_duration = T.end_time - T.start_time;disp(['Expt duration: ' num2str([T.expt_duration]) ' secs']);catch    %this "catch" section executes in case of an error in the "try" section    %above.  Importantly, it closes the onscreen window if its open.%    Screen('LoadCLUT', wptr, hardwareclut);     Priority(0);    Screen('CloseAll');    ShowCursor;    psychrethrow(psychlasterror);end %try..catch..%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Safe Save Data File% varNames = ['p s T resp calibrationFile bigRect subName scanNum theDate ']; 	% list of variables to saveSaveDataFile;	% script saves all variables in datafile, prepends "TEMP" to filename if file already exists% Code to analyze behavorial performance, detection of probes in movielistnumProbes = 0;numResp = 0;numHits = 0;numFA = 0;% numCorr = sum(resp.key(temp)==p.task_list(p.task_list>0)); 	% number of correct responsesrtWin = [0.25 1.25];	% window for analyzing RT datafor n = 1:p.nblocks	probetimes = find(p.task_list(:,n)>0) * s.onOffDur - s.onOffDur;	resptimes = resp.rt(resp.rt(:,n)>0,n) - T.start_block(n);	numResp = numResp + length(resptimes);	numProbes = numProbes + length(probetimes);		for n2 = 1:length(probetimes)		boolean = resptimes > probetimes(n2) + rtWin(1) ....					& 	resptimes < probetimes(n2) + rtWin(2);		if sum(boolean) > 0			numHits = numHits + 1;		end		endendnumFA = numResp - numHits;propHits = numHits/numProbes;propFA = numFA/numProbes;disp(['Number of correct responses = ' num2str(numHits) '/' num2str(numProbes) ]);disp(['Number of false alarms = ' num2str(numFA) '/' num2str(numProbes) ]);disp(['Percent correct (Hits - FA) = ' num2str(round((propHits-propFA)*100)) '%']);%%%%%%%%% T.start_block% p.block_switch_times% fprintf('Mean difference between ideal and actual block start times: %0.6f\n',mean(T.start_block(2:2:end)-p.block_switch_times(2:2:end-1)));% fprintf('Standard deviation of those differences:                    %0.6f\n',std(T.start_block(2:2:end)-p.block_switch_times(2:2:end-1)));% mean(T.start_trial(2:2:end,:))-p.trial_switch_times(1:end-1) %check this% std(T.start_trial(2:2:end,:))-p.trial_switch_times(1:end-1)