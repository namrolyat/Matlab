%%% one run takes 168 seconds == 84 TRs%%% Task: %%%     Press button to start, attend cued stim%%% 	Press '1' if stim in interval 1 was tilted more clockwise%%% 	Press '2' if stim in interval 2 was tilted more clockwise%%%     (or: press 1 if stim 2 was tilted counterclockwise and 2 if stim 2%%%     was tilted clockwise with respect to stim 1)%%% this file works with SetInitialCond_4scanningclose allclear all% SETTING some paramCue = 'black'; %'black' or 'white'subName = 'tmp'; %tmp, or RRtmp or RRload_quest_file=1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%train_spatfreq=1;std_orientation_offset = 2; %in degrees, jitter on stimuli within blockstd_spatfreq_offset=.01; %spatfreq_difference = 0.01;%difference between stimuli within trialsituation = 2; %0=elsewhere, 1=old scanner, 2=new scanner, 3=PAClab eyetracker, 4=417Drand('twister', sum(100*clock));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%global expdir datadir expdir = pwd;datadir='Data_Scanning'; addpath([expdir filesep 'Local_Functions']);scanNum = input('Series number for this scan?  ','s');	scanNum_counterbalance = input('Number of this scan in PercL experiment? (1-24; for counterbalancing...) ');theDate = datestr(date,2);											theDate(6) = []; theDate(3) = [];									theDate = [theDate(5:6) theDate(1:2) theDate(3:4)];				[scrnum,frameHz,pixPerDeg,bigRect,calibrationFile] = GetMonitorInfo(situation); %0=elsewhere, 1=old scanner, 2=new scanner, 4=417Dcd([expdir filesep datadir])load([theDate '_' subName 'InitialCond_4scanning'], 'master_master');cd(expdir);difference = input('Which fixed difference do you want to use?  ');spatfreq_diff = spatfreq_difference;datafile = [theDate '_' subName '_SF_Orient_FlashingStim_4scanning_LongerFix' '_r' scanNum];	% name of data file to save relevant variables%%%%%%%%%% Main Experimental Parameters %%%%%%%%%%%NumSteps = 30; %num of screen updates within the stim intervalfreq = 2; % num of sines within the stim interval, CHECK: figure, plot(sin(0:(freq*2*pi)/NumSteps:(freq*2*pi)-(freq*2*pi)/NumSteps))nVF = 2; %LVF, RVFsa.orientation = squeeze(master_master(:, scanNum_counterbalance, 1)); su.orientation = squeeze(master_master(:, scanNum_counterbalance, 2)); nPerRun = nVF * length(sa.orientation) + 2;difference = kron(difference,[-1 1]);nPerBlock = 4; %number of instances you want of each orientation (condition) to occur within one block, length must be multiple of length(difference) if mod(nPerBlock, length(difference))    error('nPerBlock must be multiple of length(difference)')end%%% Build the master mapall_attended_gratings = kron(sa.orientation, ones(nVF,1)); % Put every sa.cond once in every VF, ordered over blocks: LVF, RVF, LFV, RVF, etc. or vice versadiff_rep = length(all_attended_gratings)*nPerBlock/length(difference);	%number of times each difference must occurmaster = kron(all_attended_gratings, ones(nPerBlock,1));	%lists the values in all_attended_gratings "nPerBlock" timesmaster(:,3) = kron(ones(diff_rep,1), difference');	%lists the values in "difference" "diff_rep" times, equiv to repmatall_unattended_gratings = kron(su.orientation, ones(nVF,1)); % Put every su.cond once in every VF, ordered over blocks: LVF, RVF, LFV, RVF, etc. or vice versamaster(:,4) = kron(all_unattended_gratings, ones(nPerBlock,1));	%lists the values in all_attended_gratings "nPerBlock" timesunattended_difference = kron(difference', ones(length(difference),1));if mod(nPerBlock, length(unattended_difference))    error('nPerBlock must be multiple of length(unattended_difference)')endunatt_diff_rep = size(master,1)/length(unattended_difference);master(:,6) = kron(ones(unatt_diff_rep,1), unattended_difference);%create some random variation in the base orientations in the masteroo_dummy = randn(size(master,1)/(nPerBlock),nPerBlock/2)*std_orientation_offset;orient_offset_a = Shuffle([oo_dummy -oo_dummy]');oo_dummy = randn(size(master,1)/(nPerBlock),nPerBlock/2)*std_orientation_offset;orient_offset_u=Shuffle([oo_dummy -oo_dummy]');master(:,1) =  orient_offset_a(:) + master(:,1);master(:,4) =  orient_offset_u(:) + master(:,4);for n = 1:size(master,1)    %attended:    master(n,2) = master(n,1) + master(n,3); %calculates the s.angle for test grating based on "orientation" and the orientation difference    %unattended:    master(n,5) = master(n,4) + master(n,6);end%%spatial frequency%%%create some random variation in base of spat freqsfo_dummy = randn(size(master,1)/(nPerBlock),nPerBlock/2)*std_spatfreq_offset;sf_offset_a = Shuffle([sfo_dummy -sfo_dummy]');sfo_dummy = randn(size(master,1)/(nPerBlock),nPerBlock/2)*std_spatfreq_offset;sf_offset_u=Shuffle([sfo_dummy -sfo_dummy]');sf_master(:,1) =  sf_offset_a(:)*train_spatfreq + train_spatfreq;sf_master(:,4) =  sf_offset_u(:)*train_spatfreq + train_spatfreq;sf_diff_order=Shuffle(repmat(spatfreq_diff*[1 1 -1 -1]', [1 size(master,1)/nPerBlock])); %careful -> this assumes 4 stim in a blocksf_master(:,3) = sf_diff_order(:);sf_diff_order=Shuffle(repmat(spatfreq_diff*[1 1 -1 -1]', [1 size(master,1)/nPerBlock]));sf_master(:,6) = sf_diff_order(:);for n = 1:size(sf_master,1)    %attended:    sf_master(n,2) = sf_master(n,1) + sf_master(n,3)*sf_master(n,1); %octave    %unattended:    sf_master(n,5) = sf_master(n,4) + sf_master(n,6)*sf_master(n,4);end%%% Shuffling the matrix% all gratings, ordered: LVF, RVF, LFV, RVF, etc. or vice versatemp=[];fixInd = size(master,1)+1;master(fixInd,:)=0;sf_master(fixInd,:)=0;for n = 1:nPerBlock*length(all_attended_gratings):size(master,1)-1 %for every new run    shuff_LVF = Shuffle(n:nVF*nPerBlock:n-1+nPerBlock*length(all_attended_gratings)); % shuffle the order of orientations in LVF (or vice versa)    shuff_RVF = Shuffle(n+nPerBlock:nVF*nPerBlock:n-1+nPerBlock*length(all_attended_gratings)); % shuffle the order of orientations in RVF (or vice versa)    jnk1(1:2:length([shuff_LVF shuff_RVF]))=shuff_LVF; % and put together    jnk1(2:2:length([shuff_LVF shuff_RVF]))=shuff_RVF;    jnk2=[];    for k = 1:length(jnk1) %for every orientation, shuffle the instances        jnk2 = [jnk2 Shuffle(jnk1(k)-1+[1:nPerBlock])];     end    temp = [temp fixInd*ones(1,nPerBlock) jnk2 fixInd*ones(1,nPerBlock)]; % every run starts and ends with fixation (fixInd)end%attended gratingssa.matrix = master(temp,1:3);sa.whichStimFirst = Randi(2, [size(sa.matrix,1),1]);sa.whichStimFirst(:,2) = (sa.whichStimFirst(:,1)==1)+1;sa.whichStimFirst(:,3) = 3;for n = 1:size(sa.matrix,1)sa.finalmatrix(n,:) = sa.matrix(n,sa.whichStimFirst(n,:)); %attended gratingsend% unattended gratingssu.matrix = master(temp,4:6);su.whichStimFirst(:,1) = Randi(2, [size(su.matrix,1),1]);su.whichStimFirst(:,2) = (su.whichStimFirst(:,1)==1)+1;su.whichStimFirst(:,3) = 3;for n = 1:size(su.matrix,1)su.finalmatrix(n,:) = su.matrix(n,su.whichStimFirst(n,:)); %unattended gratingsendnTrials = size(sa.finalmatrix,1); %% # of trials %%%spatial frequencysa.spatfreq = sf_master(temp,1:3);su.spatfreq = sf_master(temp,4:6);master_whichStimFirst(:,1) = [1 2 1 2]; %left visual fieldmaster_whichStimFirst(:,2) = [1 2 2 1]; %right visual fieldStimOrder = Shuffle(repmat([1:4]', [1 nPerRun])); %counterbalance (but not necessary for this exp)sa.whichFreq(:,1) = master_whichStimFirst(StimOrder(:),1);su.whichFreq(:,1) = master_whichStimFirst(StimOrder(:),2);sa.whichFreq(:,2) = (sa.whichFreq(:,1)==1)+1;su.whichFreq(:,2) = (su.whichFreq(:,1)==1)+1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%phase1 = []; phase2 = []; phase3 = []; phase4 = [];jnk = linspace(0,2*pi,nPerBlock+1);steps=jnk(1:end-1);for jnk = 1:nTrials/nPerBlock    phase1 = [phase1 Shuffle(rem(steps+rand*2*pi,2*pi))];    phase2 = [phase2 Shuffle(rem(steps+rand*2*pi,2*pi))];    phase3 = [phase3 Shuffle(rem(steps+rand*2*pi,2*pi))];    phase4 = [phase4 Shuffle(rem(steps+rand*2*pi,2*pi))];endsa.phase(:,1) = phase1'; sa.phase(:,3) = rem(phase1'+pi,2*pi);sa.phase(:,2) = phase2'; sa.phase(:,4) = rem(phase2'+pi,2*pi);su.phase(:,1) = phase3'; su.phase(:,3) = rem(phase3'+pi,2*pi);su.phase(:,2) = phase4'; su.phase(:,4) = rem(phase4'+pi,2*pi);% Attended stim in VFsfirst_VF = rem(str2num(scanNum),2)+1; %odd=2, even=1;% first_VF = rem(str2num(scanNum)+1,2)+1; %odd=1, even=2if first_VF==1    sa.VF = repmat(kron([1 2]', ones(nPerBlock,1)), [(length(all_attended_gratings)+2)/2 1]);%%1 = Left, 2 = Rightelseif first_VF==2    sa.VF = repmat(kron([2 1]', ones(nPerBlock,1)), [(length(all_attended_gratings)+2)/2 1]);%%1 = Left, 2 = Rightendsu.VF = (sa.VF==1)+1;response = zeros(nTrials,5);	%create the response variable%Timing Parameters for Experimentp.cue = .25;p.postcue = .25; %2/3-.25p.stimdur = 1/NumSteps;p.isi = .5; p.poststim = 1;p.trial_dur = p.cue+p.postcue+2*NumSteps*p.stimdur+p.isi+p.poststim;% p.fix_dur = p.trial_dur/2;p.block_switch_times = [p.trial_dur*(nPerBlock:nPerBlock:nTrials)];	% when to switch between blocksp.trial_switch_times = [p.trial_dur*(1:nTrials)]; % when to switch between trials% p.trial_switch_times = [p.fix_dur*(1:nPerBlock) (nPerBlock*p.fix_dur + p.trial_dur*(1:nTrials-2*nPerBlock)) ....%      (nPerBlock*p.fix_dur + p.trial_dur*(nTrials-2*nPerBlock) + p.fix_dur*(1:nPerBlock))];	% when to switch between trialsp.first_grating_start_times = [p.cue+p.postcue+(p.trial_dur*(0:nTrials-1))]; %%DEBUGp.k_grating_start_times1 = [p.stimdur*(0:NumSteps-1)];p.k_grating_start_times2 = [p.k_grating_start_times1+p.stimdur*NumSteps+p.isi];p.randseed = rand('state'); % stores the current state of the rand number generator%add 8 seconds to the last fixation period(in order to obtain a better%estimate of the baseline activityp.trial_switch_times(end) = p.trial_switch_times(end)+8;p.block_switch_times(end) = p.block_switch_times(end)+8; %DEBUG%%%% GAMMA-CORRECTED COLOR LOOK-UP TABLEp.meanLum = 0.5;p.contrast = 1;p.amp = p.meanLum * p.contrast;[gamInverse,dacsize] = LoadCalibrationFileVL(calibrationFile);		% function loads inverse gamma table and screen dacsize from most recent calibration file							ncolors = 255;	% number of gray levels to use in mpcmaplist, should be unevenmpcmaplist = zeros(256,3);	% color look-up table of 256 RGB values, RANGE 0-1temptrial = linspace(p.meanLum-p.amp, p.meanLum+p.amp, ncolors)';	% make grayscale gradientbcolor_idx = find(temptrial==.5) -1;	% idx of background color in mpcmaplist, subtract 1 for range 0-255 black_idx = find(temptrial==0) -1;white_idx = find(temptrial==1) -1;mpcmaplist(1:ncolors,:) = repmat(temptrial, [1 3]);mpcmaplist(256,1:3) = 1;mpcmaplist = round(map2map(mpcmaplist,gamInverse));%%%% More Stim Params.eccen = 5;s.size_in_degree = 7;s.size_in_pixels = round([s.size_in_degree*pixPerDeg s.size_in_degree*pixPerDeg]);	% width, height of stimuluss.loc(1,:) = [(round((bigRect(3)-s.size_in_pixels(1))/2) -round(s.eccen*pixPerDeg)), round((bigRect(4)-s.size_in_pixels(2))/2)]; % 1 = left from fixations.loc(2,:) = [(round((bigRect(3)-s.size_in_pixels(1))/2) +round(s.eccen*pixPerDeg)), round((bigRect(4)-s.size_in_pixels(2))/2)]; % 2 = right from fixations.rect = [s.loc s.loc + repmat(s.size_in_pixels, [2 1])];s.meanColorIdx = ceil((ncolors)/2) -1;	% mean color number (0-255) of stimulus (used to index rows 1:256 in mpcmaplist) s.ampColorIdx = floor((ncolors-1)/2);		% amplitude of color variation for stimulusjnk = Randi(2, [nTrials,1]);sa.ampl_offset = repmat(zeros(nTrials,1), [1 NumSteps]); %rand(nTrials,1)*2*pi   %(jnk == 1)*.5*pi  %%CHANGE TEMP PHASE HEREsu.ampl_offset = repmat(zeros(nTrials,1), [1 NumSteps]); sa.ampl_mod = sin(repmat(0:(freq*2*pi)/NumSteps:(freq*2*pi)-(freq*2*pi)/NumSteps, [nTrials 1])+sa.ampl_offset); su.ampl_mod = sin(repmat(0:(freq*2*pi)/NumSteps:(freq*2*pi)-(freq*2*pi)/NumSteps, [nTrials 1])+su.ampl_offset); length_ampl_mod = size(sa.ampl_mod,2);if (s.meanColorIdx ~= bcolor_idx)    error('background ColorIdx and mean ColorIdx are not the same')end% mask paramr_center = 0;	% middle of Gaussian envelopestart_linear_decay_in_degree = .5; start_linear_decay = round(s.size_in_pixels(2)/2-start_linear_decay_in_degree*pixPerDeg);r_thresh = round(s.size_in_pixels(2)/2);	% cue paramdot.eccen = .5;dot.size_in_degree = .25;dot.size_in_pixels = ceil([dot.size_in_degree*pixPerDeg dot.size_in_degree*pixPerDeg]); %%DEBUG: made sure that cue and fix are equal in sizedot.radius_in_pixels = round(dot.size_in_pixels(1)/2);dot.loc(1,:) = [(round((bigRect(3)-dot.size_in_pixels(1))/2) -round(dot.eccen*pixPerDeg)), round((bigRect(4)-dot.size_in_pixels(2))/2)]; % 1 = left from fixationdot.loc(2,:) = [(round((bigRect(3)-dot.size_in_pixels(1))/2) +round(dot.eccen*pixPerDeg)), round((bigRect(4)-dot.size_in_pixels(2))/2)]; % 2 = right from fixationdot.rect = [dot.loc dot.loc + repmat(dot.size_in_pixels, [2 1])];% fixation paramb.eccen = 0;b.radius_in_degree = .25;b.radius_in_pixels = round([1/3 2/3 1]*b.radius_in_degree*pixPerDeg);	% radius of fixation bull's eye  b.loc = round([(bigRect(3)/2 -b.radius_in_pixels(3)), (bigRect(4)/2 -b.radius_in_pixels(3))]);b.rect = [b.loc b.loc + 2*[b.radius_in_pixels(3) b.radius_in_pixels(3)]];%%%% BEGIN EXP tryHideCursor; %%DEBUG% screens=Screen('Screens');% screenNumber=max(screens);[wptr,rect] = Screen('OpenWindow', 0, bcolor_idx, [], 8);hardwareclut=Screen('LoadCLUT', wptr);Screen('LoadCLUT', wptr, mpcmaplist); %OSx USE LoadNormalizedGammaTable, but: Gamma Table Values must be in interval 0 =< x =< 1% create fixation img = MakeFixation(black_idx, white_idx, bcolor_idx, b.radius_in_pixels(1),b.radius_in_pixels(2),b.radius_in_pixels(3));blanker = Screen('MakeTexture', wptr, img);Screen('DrawTexture', wptr, blanker, [], b.rect);Screen('Flip', wptr);% draw fixation point% create cueing dotif strcmp(Cue,'black')img = MakeFixation(black_idx, bcolor_idx, bcolor_idx, dot.radius_in_pixels);attended_cue = Screen('MakeTexture', wptr, img);img = MakeFixation(white_idx, bcolor_idx, bcolor_idx, dot.radius_in_pixels);unattended_cue = Screen('MakeTexture', wptr, img);elseif strcmp(Cue,'white')img = MakeFixation(white_idx, bcolor_idx, bcolor_idx, dot.radius_in_pixels);attended_cue = Screen('MakeTexture', wptr, img);img = MakeFixation(black_idx, bcolor_idx, bcolor_idx, dot.radius_in_pixels);unattended_cue = Screen('MakeTexture', wptr, img);end    % create stimattendImglist = zeros(nTrials,2,length_ampl_mod);unattendImglist = zeros(nTrials,2,length_ampl_mod);mask1 = makeLinearMaskCircle(s.size_in_pixels(2),s.size_in_pixels(1), r_center, start_linear_decay, r_thresh); %create maskfor trial=1:nTrials    if (sa.finalmatrix(trial,1)~=0 || sa.finalmatrix(trial,2)~=0) %% if not fixation        % first presentation, attended stim        img = makeSineGrating(s.size_in_pixels(2), s.size_in_pixels(1), sa.spatfreq(trial,sa.whichFreq(trial,1)), ....                sa.finalmatrix(trial,1)*pi/180, sa.phase(trial,1), 0, 1, pixPerDeg);         img = img.*mask1;        for temp_phase = 1:length_ampl_mod            new_img = round(img*s.ampColorIdx*sa.ampl_mod(trial, temp_phase)+s.meanColorIdx);               attendImglist(trial,1,temp_phase) = Screen('MakeTexture', wptr, new_img);        end        % first presentation, unattended stim        img = makeSineGrating(s.size_in_pixels(2), s.size_in_pixels(1), su.spatfreq(trial,su.whichFreq(trial,1)), ....                su.finalmatrix(trial,1)*pi/180, su.phase(trial,1), 0, 1, pixPerDeg);         img = img.*mask1;        for temp_phase = 1:length_ampl_mod            new_img = round(img*s.ampColorIdx*su.ampl_mod(trial, temp_phase)+s.meanColorIdx);               unattendImglist(trial,1,temp_phase) = Screen('MakeTexture', wptr, new_img);        end        % second presentation, attended stim        img = makeSineGrating(s.size_in_pixels(2), s.size_in_pixels(1), sa.spatfreq(trial,sa.whichFreq(trial,2)), ....                sa.finalmatrix(trial,2)*pi/180, sa.phase(trial,2), 0, 1, pixPerDeg);         img = img.*mask1;        for temp_phase = 1:length_ampl_mod            new_img = round(img*s.ampColorIdx*sa.ampl_mod(trial, temp_phase)+s.meanColorIdx);               attendImglist(trial,2,temp_phase) = Screen('MakeTexture', wptr, new_img);        end        % second presentation, unattended stim        img = makeSineGrating(s.size_in_pixels(2), s.size_in_pixels(1), su.spatfreq(trial,su.whichFreq(trial,2)), ....                su.finalmatrix(trial,2)*pi/180, su.phase(trial,2), 0, 1, pixPerDeg);         img = img.*mask1;        for temp_phase = 1:length_ampl_mod            new_img = round(img*s.ampColorIdx*su.ampl_mod(trial, temp_phase)+s.meanColorIdx);               unattendImglist(trial,2,temp_phase) = Screen('MakeTexture', wptr, new_img);        end    endend% Start Experiment: prepare presentation screen, color table, and clear screenFlushEvents('keyDown');		% discard all characters from the Event Manager queue					txt = 'Waiting for trigger to begin';			txtloc = [50 50];Screen('TextSize',wptr,14); %set style and size of textScreen('TextStyle',wptr,1);Screen('DrawTexture', wptr, blanker, [], b.rect);Screen('DrawText',wptr,txt,txtloc(1), txtloc(2),255); %add text to fixation pointScreen('Flip', wptr);% draw text message, reader for exp'twaitTrigger;	% exp't starts after MR trigger sends ` keyScreen('DrawTexture', wptr, blanker, [], b.rect);Screen('Flip', wptr);% draw fixation point% priorityLevel=MaxPriority(wptr);% Priority(priorityLevel);half_flip_interval = 0.5*Screen('GetFlipInterval',wptr); % Create value in seconds that is half the frame period.trial = 0;for block = 1:nPerRun        block_start_flag = 1;    for trial_per_block = 1:nPerBlock         trial = trial + 1;        if (sa.finalmatrix(trial,1)==0 && sa.finalmatrix(trial,2)==0)                        Screen('DrawTexture', wptr, blanker, [], b.rect);            flip_time_stamp = Screen('Flip', wptr); % fixation presentation            if (trial > 1)                T.trial(trial - 1) = flip_time_stamp - T.start_time;            end            if (block_start_flag && block == 1)                T.start_time = flip_time_stamp;                block_start_flag = 0;            elseif (block_start_flag)                T.block(block - 1) = flip_time_stamp - T.start_time;                block_start_flag = 0;            end        else            Screen('DrawTextures', wptr, [blanker attended_cue unattended_cue], [], [b.rect; dot.rect(sa.VF(trial),:); dot.rect(su.VF(trial),:)]');            flip_time_stamp = Screen('Flip', wptr); % cue presentation            if (trial > 1)                T.trial(trial - 1) = flip_time_stamp - T.start_time;            end            if (block_start_flag && block == 1)                T.start_time = flip_time_stamp;                block_start_flag = 0;            elseif (block_start_flag)                T.block(block - 1) = flip_time_stamp - T.start_time;                block_start_flag = 0;            end            Screen('DrawTexture', wptr, blanker, [], b.rect); % Prepare next video page before starting wait period for current video page.            while (GetSecs - flip_time_stamp < p.cue - half_flip_interval) % Subtracting half flip interval gives plenty of slack to catch the desired frame for change.                WaitSecs(0.001)            end            flip_time_stamp = Screen('Flip', wptr); % post-cue fixation presentation                        % Prepare next video page...            Screen('DrawTextures', wptr, [attendImglist(trial,1,1) unattendImglist(trial,1,1) blanker], [], [s.rect(sa.VF(trial),:); s.rect(su.VF(trial),:); b.rect]');            %% end prepare                        while (GetSecs - flip_time_stamp < p.postcue - half_flip_interval); %wait remaining postcue time                WaitSecs(0.001);            end            flip_time_stamp = Screen('Flip', wptr); % 1st grating presentation            T.first_grating(trial) = flip_time_stamp - T.start_time;            T.k_grating1(trial,1) = flip_time_stamp;                        for k = 2:length_ampl_mod                                Screen('DrawTextures', wptr, [attendImglist(trial,1,k) unattendImglist(trial,1,k) blanker], [], [s.rect(sa.VF(trial),:); s.rect(su.VF(trial),:); b.rect]'); %%rem(k,length_ampl_mod)+1                while (GetSecs - flip_time_stamp < p.stimdur - half_flip_interval) % Subtracting half flip interval...                    WaitSecs(0.001);                end                flip_time_stamp = Screen('Flip',wptr); %new stim presentation                T.k_grating1(trial,k) = flip_time_stamp - T.k_grating1(trial,1);                        end % end k            Screen('DrawTexture', wptr, blanker, [], b.rect); % next video page...            while (GetSecs - flip_time_stamp < p.stimdur - half_flip_interval) % Subtracting half flip interval...                WaitSecs(0.001);            end            flip_time_stamp = Screen('Flip', wptr);% isi fixation presentation                                    % Prepare next video page...            Screen('DrawTextures', wptr, [attendImglist(trial,2,1) unattendImglist(trial,2,1) blanker], [], [s.rect(sa.VF(trial),:); s.rect(su.VF(trial),:); b.rect]');             while (GetSecs - flip_time_stamp < p.isi - half_flip_interval) % wait remaining isi interval, subtracting half flip interval...                WaitSecs(0.001);            end            flip_time_stamp = Screen('Flip', wptr);% 2nd grating presentation            T.k_grating2(trial,1) = flip_time_stamp - T.k_grating1(trial,1);                        for k = 2:length_ampl_mod                                Screen('DrawTextures', wptr, [attendImglist(trial,2,k) unattendImglist(trial,2,k) blanker], [], [s.rect(sa.VF(trial),:); s.rect(su.VF(trial),:); b.rect]'); % Prepare next video page...                while (GetSecs - flip_time_stamp < p.stimdur - half_flip_interval) % Subtracting half flip interval...                    WaitSecs(0.001);                end                flip_time_stamp = Screen('Flip', wptr);% %new stim presentation                T.k_grating2(trial,k) = flip_time_stamp - T.k_grating1(trial,1);            end % end k                                    Screen('DrawTexture', wptr, blanker, [], b.rect); % Prepare next video page...            while (GetSecs - flip_time_stamp < p.stimdur - half_flip_interval) % Subtracting half flip interval...                WaitSecs(0.001);            end            flip_time_stamp = Screen('Flip', wptr); % post_stim fixation presentation            %             GetChar; %%DEBUG        end        response(trial,1) = -1; % Initialize with -1 in case subject does not respond.        response(trial,2) = -1; % Initialize with -1 in case subject does not respond.        correctResp = find(sa.finalmatrix(trial,1:2)==min(sa.finalmatrix(trial,1),sa.finalmatrix(trial,2)));         if length(correctResp)==1        response(trial,3)=correctResp; % correct response        else        response(trial,3)=0;        end        FlushEvents('keyDown');  %%ALTERN        keyboard_response_detected = 0;        while (GetSecs - T.start_time < p.trial_switch_times(trial) - half_flip_interval)                                    if(CharAvail)	% check for keypress, record if key=1 or 2                [char, when] = GetChar;                if (char =='1' || char == '2')                    response(trial,1) =  str2num(char);	                    response(trial,2) = when.secs-T.start_time; % record time of keypress                end                FlushEvents('keyDown');		% discard all characters from the Event Manager queue					            end	                                end %while            end %trial_per_blockend %block% One last flip to properly record time of end of last trial, end of last% block, and end of run.flip_time_stamp = Screen('Flip', wptr);T.trial(trial) = flip_time_stamp - T.start_time;T.block(block) = flip_time_stamp - T.start_time;T.end_time = flip_time_stamp;Screen('LoadCLUT', wptr, hardwareclut); % Priority(0);Screen('CloseAll');ShowCursor;disp('Experiment done');T.expt_duration = T.end_time - T.start_time;disp(['Expt duration: ' num2str([T.expt_duration]) ' secs']);catch    %this "catch" section executes in case of an error in the "try" section    %above.  Importantly, it closes the onscreen window if its open.    Screen('LoadCLUT', 0, hardwareclut); %     Priority(0);    Screen('CloseAll');    ShowCursor;    psychrethrow(psychlasterror);end %try..catch..%%%% Save Data% varNames = ['p s sa su dot T response bigRect subName scanNum theDate calibrationFile q']; 	% list of variables to save  SaveDataFile;	% script saves all variables in datafile, prepends "TEMP" to filename if file already exists% T.trial% p.trial_switch_times% % fprintf('Mean difference between ideal and actual trial start times: %0.6f\n',mean(T.trial - p.trial_switch_times));% fprintf('Standard deviation of those differences:                    %0.6f\n',std(T.trial - p.trial_switch_times));% fprintf('\n');% % jnk = T.k_grating1(nPerBlock+1:end,2:end) - repmat(p.k_grating_start_times1(2:end), [nTrials-2*nPerBlock, 1]);% fprintf('Mean difference between ideal and actual k stim1 start times: %0.6f\n',mean(jnk(:)));% fprintf('Standard deviation of those differences:                    %0.6f\n',std(jnk(:)));% fprintf('\n');% % jnk = T.k_grating2(nPerBlock+1:end,:) - repmat(p.k_grating_start_times2, [nTrials-2*nPerBlock, 1]);% fprintf('Mean difference between ideal and actual k stim2 start times: %0.6f\n',mean(jnk(:)));% fprintf('Standard deviation of those differences:                    %0.6f\n',std(jnk(:)));% fprintf('\n');% % T.block% p.block_switch_timesfprintf('Mean difference between ideal and actual first grating start times: %0.6f\n',mean(T.first_grating(nPerBlock+1:end) - p.first_grating_start_times(nPerBlock+1:end-nPerBlock)));fprintf('Standard deviation of those differences: %0.6f\n',std(T.first_grating(nPerBlock+1:end) - p.first_grating_start_times(nPerBlock+1:end-nPerBlock)));fprintf('\n');%%%%%%numHits = sum(response(:,1) == response(:,3));numProbes = sum(response(:,3)>0);numResp = sum(response(:,1)>0);numFA = numResp - numHits;propHits = numHits/numProbes;propFA = numFA/numProbes;fprintf('\n**************************************\n\n');disp(['Number of correct responses = ' num2str(numHits) '/' num2str(numProbes) ]);% disp(['Number of false alarms = ' num2str(numFA) '/' num2str(numProbes) ]);% disp(['Percent correct (Hits - FA) = ' num2str(round((propHits-propFA)*100)) '%']);